<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> GSOC: Handle Nested Languages Overview | Thinkspace </title> <meta name="description" content=" A Brief explanation of what my GSOC project is about "> <meta name="keywords" content="GSoC, internship, Nested Languages"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="Naveen Naidu"> <meta property="article:section" content=""> <meta property="article:tag" content="GSoC, internship, Nested Languages"> <meta property="article:published_time" content="2019-06-14 00:00:00 +0530"> <meta property="og:url" content="http://localhost:4000/2019/GSoC-Overview-Hanlde-Nested-Languages/"> <meta property="og:title" content=" GSOC: Handle Nested Languages Overview | Thinkspace "> <meta property="og:image" content="http://localhost:4000"> <meta property="og:description" content=" A Brief explanation of what my GSOC project is about "> <meta property="og:site_name" content="Naveen Naidu"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content=""> <meta name="twitter:title" content=" GSOC: Handle Nested Languages Overview | Thinkspace "> <meta name="twitter:description" content=" A Brief explanation of what my GSOC project is about "> <meta name="twitter:image:src" content="http://localhost:4000"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" GSOC: Handle Nested Languages Overview | Thinkspace "> <meta itemprop="description" content=" A Brief explanation of what my GSOC project is about "> <meta itemprop="image" content="http://localhost:4000"> <!-- Canonical link tag --> <link rel="canonical" href="http://localhost:4000/2019/GSoC-Overview-Hanlde-Nested-Languages/"> <link rel="alternate" type="application/rss+xml" title="Thinkspace" href="http://localhost:4000/feed.xml"> <!-- rel prev and next --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="http://localhost:4000/">Think<span>space</span></a></h1> <ul class="navbar"> <li><a href="http://localhost:4000/about">About me</a></li> <li><a href="http://localhost:4000/feed.xml" target="_blank">RSS</a></li> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2019-06-14T00:00:00+05:30" itemprop="datePublished">Jun 14, 2019</time></p> <h1 class="post-title" itemprop="name headline">GSOC: Handle Nested Languages Overview</h1> </header> <div class="post-content" itemprop="articleBody"> <p>Hola Amigos!</p> <p>The <code class="highlighter-rouge">Coding Phase - 1 </code> of GSoC has started and it has been pretty fun. I also have my University Finals going on now. They’ll end on July 3rd. Banglore does live in a different kind of world :P - Phew! This is a really busy month. I have to manage Finals, GSoC and Open Mainframe Internship cocurrently. I like this kind of atmosphere though. It keeps me on my toes and pushes me to break my own boundaries and limits that I so absent mindedly set upon on myself. And it’s pretty damn fun.</p> <p>There’s a different craze - The adrenaline that rushes through your body, when you put on your headphones, and sit infront of your laptop to code and learn lot’s of new stuff everyday. <code class="highlighter-rouge">It's finger licking good</code> (<em>EWWW! You can come with better exclamation Naveen :facepalm:</em>). There has been a lot of Aha! moments until now as well. And some moments where I felt like hitting <code class="highlighter-rouge">Anne</code> so hard that all her teeths come out. Oh! For the unintiated - Anne is the name of my Laptop. She’s so fucking good. Especially when the red color light’s her body up. Alright! I won’t go on about Anne more - Else it would get more intimate :speak_no_evil: But all in all - Anne is a good girl and she’s mine. So People! Keep your hands of her - It’s pretty well encrypted anyways - You won’t be able to get any fun just by laying your hands on it. Hehehe!</p> <p>Ah! Here it is again. I shifted from the topic - And I’m too lazy to go back and erase it up. So I’ll let that be there anyway.</p> <p>Coming back to the point! This post is to introduce you(<em>you - as in the bots of the internet</em>) about <code class="highlighter-rouge">What my project is?</code> and <code class="highlighter-rouge">A brief Overview of the project</code>.</p> <p>The title of my project is <code class="highlighter-rouge">Handle Nested languages</code>.</p> <p><strong><em>The proposal for this project is present <a href="https://docs.google.com/document/d/16M3KMf8pS0NmuFPeWR0hVbK-kpZZEKDKs3CQwXmOBu4/edit?usp=sharing">here</a></em></strong></p> <h2 id="introduction">Introduction</h2> <p>coala in its present state is capable of providing efficient static analysis to only those file that contains a single programming language. But Multiple programming languages can coexist in a single source file.Eg: <code class="highlighter-rouge">PHP and HTML</code> , <code class="highlighter-rouge">HTML and Jinja</code> , <code class="highlighter-rouge">Python and Jinja</code> , <code class="highlighter-rouge">codeblocks and RST</code> etc.</p> <p>coala does not yet support these kind of files. This project would enable coala to deal with those situations and allow people to write code analysis similar to how they already do it while being applicable to the right locations at the right files.The users of coala would not have to concentrate on writing new bears/ analysis routines. This implementation would perfectly work with the existing bears.</p> <p>There can be several ways to approach this. In this cEP, we will be implementing a abstract way which will support arbitrary combination of languages.</p> <h2 id="a-higher-level-view-of-the-implementation">A higher level view of the implementation</h2> <p>A source file containing multiple programming languages is loaded up by coala. The original nested file is broken/split into <code class="highlighter-rouge">n</code> temporary files, where n is the number of languages present in the original file. Each temporary file only contains the snippets belonging to one language.</p> <p>These temporary files would then be passed to their respective language bears ( <em>chosen by the user</em>) where the static analysis routines would run. The temporary files after being linted would then be assembled.</p> <p>The above process creates the illusion that the original file is being linted, but in reality we divide the files into different parts and lint them one by one.</p> <p>The figure below, would help give a clear picture</p> <p><img src="https://github.com/Naveenaidu/gsoc-18-materials/blob/master/photos/high_level_view_handle_nested.jpg" alt="higher_level_view" /></p> <h2 id="nested-language-section-nl_section">Nested Language Section (nl_section)</h2> <p>The original file is segregated into small pieces/units where each piece/unit purely contains only <code class="highlighter-rouge">one language</code>. These quantum pieces of the the nested original file is termed as <code class="highlighter-rouge">nl_section</code>.</p> <p>A <code class="highlighter-rouge">nl_section</code> can further be defined as a group of lines in the source code that purely belongs to one particular language.</p> <p>All the <code class="highlighter-rouge">nl_sections</code> that belong to one particular language are grouped to form a valid file of that programming language.</p> <p>The following figure would make the things clear</p> <p><img src="https://github.com/Naveenaidu/gsoc-18-materials/blob/master/photos/file_section.jpg" alt="nl_sections" /></p> <p>In the above figure, we have a file which contains both HTML and PHP code. This original file can be broken up into 4 different sections.</p> <p>Each nl_section will contain the following information:</p> <ol> <li>The Programming language of the lines</li> <li>Index of the section</li> <li>Starting Line number in the original file</li> <li>Ending Line number in the original file</li> <li>Starting line number in the linted file</li> <li>Ending line number in the linted file</li> </ol> <h1 id="prototype-of-nl_section">Prototype of nl_section</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NlSection</span><span class="p">(</span><span class="n">TextRange</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">orig_start</span><span class="p">:</span> <span class="n">NlSectionPosition</span><span class="p">,</span>
                 <span class="n">orig_end</span><span class="p">:</span> <span class="p">(</span><span class="n">NlSectionPosition</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                 <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">language</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">"""
        Creates a new NlSection.

        :param orig_start:  A NlSectionPosition indicating the start of the 
                            section in original file.
        :param orig_end:    A NlSectionPosition indicating the end of the 
                            section in the original file.
                            If ``None`` is given, the start object will be used
                            here. end must be in the same file and be greater
                            than start as negative ranges are not allowed.
        :param language:    The programming language of the lines.
        :param index:       The index of the nl_section.
        :raises TypeError:  Raised when
                            - start is not of type NlSectionPosition.
                            - end is neither of type NlSectionPosition, nor 
                              is it None.
        :raises ValueError: Raised when file of start and end mismatch.
        """</span>
        <span class="n">TextRange</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">language</span>

        <span class="s">"""
        :linted_start: The start of the section in the linted file.Initially it 
                       is same as that of the start of the original file. It 
                       changes only when any patches are applied on that line.
        :linted_end:   The end of the section in the linted file.Initially it 
                       is same as that of the end of the original file. It 
                       changes only when any patches are applied on that line.
        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linted_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linted_end</span> <span class="o">=</span> <span class="n">end</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="nb">file</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="nb">file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'File of start and end position do not match.'</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span>
                    <span class="nb">file</span><span class="p">,</span>
                    <span class="n">start_line</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">start_column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">end_line</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">end_column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">language</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">NlSectionPosition</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">start_line</span><span class="p">,</span> <span class="n">start_column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_line</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end_column</span> <span class="ow">and</span> <span class="n">end_column</span> <span class="o">&gt;</span> <span class="n">start_column</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">NlSectionPosition</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">end_line</span> <span class="k">if</span> <span class="n">end_line</span> <span class="k">else</span> <span class="n">start_line</span><span class="p">,</span>
                                 <span class="n">end_column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>


</code></pre></div></div> <h3 id="note">Note</h3> <p>The implementation of the nested language architecture would be done inside the a new folder called as <code class="highlighter-rouge">nestedlib</code> . This <code class="highlighter-rouge">nestedlib</code> would be present under the <code class="highlighter-rouge">coalib</code> directory.</p> <h2 id="architecture">Architecture</h2> <p>The following figure depicts the architecture that is going to be implemented to enable nested languages support.</p> <p><img src="https://github.com/Naveenaidu/gsoc-18-materials/blob/master/photos/arch-detailed.jpg" alt="Architecture" /></p> <ul> <li><strong>NLCore</strong></li> </ul> <p>This is the heart of the project. It is responsible to manage the execution flow in the program</p> <ul> <li><strong>NLInfoExtractor</strong></li> </ul> <p>NLInfoExtractor is responsible to extract the information from the user’s input. The extracted information would include the languages present in the file, bears to run for each programming language and the settings of these bears.</p> <ul> <li><strong>Parser</strong></li> </ul> <p>Parser splits up the original nested file into different <code class="highlighter-rouge">nl_sections</code>.</p> <ul> <li><strong>NLFileHandler</strong></li> </ul> <p>NL FileHandler is responsible for creating the temporary files (<em>which contains all the sections belonging to a single language</em>) that would be passed for the actual analysis.</p> <h2 id="implementation">Implementation</h2> <p>This project will be implemented in four phases:</p> <ul> <li>Information Gathering</li> <li>Segregating the file</li> <li>Linting the file</li> <li>Assembling</li> </ul> <h2 id="phase-1-information-gathering">Phase 1: Information Gathering</h2> <p>The users can inform coala about the presence of nested languages in the files using the <code class="highlighter-rouge">--handle-nested</code> flag.</p> <p>eg:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coala <span class="nt">--handle-nested</span> <span class="nt">--files</span><span class="o">=</span>html_php_file.html <span class="nt">--language</span><span class="o">=</span>html,php <span class="nt">--bears</span><span class="o">=</span>HTMLBear,PHPBear 
</code></pre></div></div> <ul> <li><code class="highlighter-rouge">--languages</code>: Informs coala about the languages present in the file</li> <li><code class="highlighter-rouge">--bears</code>: Informs coala about the bears to run on the file.</li> </ul> <p>The aim of information gathering is to extract the following information from the arguments passed to coala:</p> <ol> <li>Languages present in the file</li> <li>Language and Bear association</li> <li>Argument list (<strong>would be used to create coala sections</strong>)</li> </ol> <p>The languages present in the file can easily be gathered from the <code class="highlighter-rouge">--language</code> tag. The language and Bear association information can be attained by using the meta information of the bear and matching it with the <code class="highlighter-rouge">--languages</code>.</p> <p><code class="highlighter-rouge">NlInfoExtractor</code> is responsible for the above tasks.</p> <p>The original nested language file is divided into various temporary in-memory files, where each file contains the snippets of one particular language. The linting needs to be done by the respective bears on each of the file.</p> <p>In order to do so, we would have to create <code class="highlighter-rouge">virtual coala sections</code> for each file.</p> <p>Each section, would contain the information about the files to be linted, the bears to run on those files and the setting to initialize the bear with. In order to create these sections we would need the <code class="highlighter-rouge">arguments</code> to be passed to the <code class="highlighter-rouge">parse_cli()</code> method. The arguments used to initialize coala in nested language mode cannot be used to create the coala sections.</p> <p>The NlInfoExtractor converts the original arguments into different argument list, where each argument list resembles the argument that a user would have passed if he was linting a single temp_file with the appropriate bears.</p> <p>For eg:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coala <span class="nt">--handle-nested</span> <span class="nt">--file</span><span class="o">=</span>html_php_file.html <span class="nt">--language</span><span class="o">=</span>html,php <span class="nt">--bears</span><span class="o">=</span>HTMLBear,PHPBear 
</code></pre></div></div> <p>gets converted to:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coala <span class="nt">--file</span><span class="o">=</span>temp_html_file <span class="nt">--language</span><span class="o">=</span>html <span class="nt">--bears</span><span class="o">=</span>HTMLBear 
</code></pre></div></div> <p>and</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coala <span class="nt">--file</span><span class="o">=</span>temp_php_file <span class="nt">--language</span><span class="o">=</span>php <span class="nt">--bears</span><span class="o">=</span>PHPBear  
</code></pre></div></div> <p>The above arguments when passed to the <code class="highlighter-rouge">parse_cli()</code> method, creates two section:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>nl.html]
files <span class="o">=</span> temp_html_file
bears <span class="o">=</span> HTMLBear
setting <span class="o">=</span> value

<span class="o">[</span>nl.php]
files <span class="o">=</span> temp_php_file
bears <span class="o">=</span> PHPBear
setting <span class="o">=</span> value
</code></pre></div></div> <h3 id="nlinfoextractorpy-prototype">NlInfoExtractor.py Prototype</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_info</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
	<span class="s">"""
	Return a dictionary called as `nl_info_dict` with all the extracted 
	information.

	Let's assume that we have the following arguments

	&gt;&gt;&gt;args = coala --handle-nested --file=html_php_file.html --language=html,php --bears=HTMLBear,PHPBear

	&gt;&gt;&gt; nl_info_dict = extract_info(args)

	&gt;&gt;&gt; nl_info_dict
	{
		"file_name": html_php_file.html,
		"absolute_file_path": /home/test/html_php_file.html,
		"languages": [html, php]
		"bears": [HTMLBear, PHPBear]
		"language_bear_dict": language_bear_dict
		"arg_dict": arg_dict
	}

	&gt;&gt;&gt; nl_info_dict['language_bear_dict']
	{
		"html": [HTMLBear],
		"php" : [PHPBear]
	}

	&gt;&gt;&gt; nl_info_dict['arg_dict']
	{
		"nl.html":	{"file_name": "temp_html_file",
				"bears": 'HTMLBear',
				"settings": [(setting,value)]
				}
		
		
		"nl.php": 	{"file_name": "temp_php_file",
				"bears": 'PHPBear',
				"settings": [(setting,value)]
				}

	}


	"""</span>

<span class="k">def</span> <span class="nf">get_lang_info</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
	<span class="s">"""Return a list of langauges present in the nested file"""</span>

<span class="k">def</span> <span class="nf">get_bear_info</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
	<span class="s">"""Return the list of bears to be run on the file"""</span>

<span class="k">def</span> <span class="nf">get_file_info</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
	<span class="s">"""Returns the list of files to be linted"""</span>

<span class="k">def</span> <span class="nf">get_absolute_file_path</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
	<span class="s">"""Returns the absolute file path of eacg file"""</span>

<span class="k">def</span> <span class="nf">get_language_bear_dict</span><span class="p">(</span><span class="n">languages</span><span class="p">,</span> <span class="n">bears</span><span class="p">):</span>
	<span class="s">"""
	Return a language_bear dict, where each language is mapped to a set of bears
	"""</span>

<span class="k">def</span> <span class="nf">get_argument_dict</span><span class="p">(</span><span class="n">file_list</span><span class="p">,</span> <span class="n">language_bear_dict</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
	<span class="s">"""
	Returns a argument_dict, where each temp_file is mapped to a set of
	arguments.
	"""</span>

</code></pre></div></div> <p>different <code class="highlighter-rouge">nl_sections</code> and creating temporary files for each nested languages, which would contain the snippets of that language from the original nested file.</p> <p>This phase uses the <code class="highlighter-rouge">Parser</code> and the <code class="highlighter-rouge">NlFileHandler</code> parts of the architecture.</p> <h3 id="parser">Parser</h3> <ul> <li> <p>Parser is responsible for splitting the original file into different <code class="highlighter-rouge">nl_sections</code>.</p> </li> <li> <p>The input and output to the parser is <strong>standardized</strong>, where the input to the parser are the contents of the original nested file and the output is the list of nl_sections encompassing the snippets of different programming language.</p> </li> <li> <p>Standardizing the parser helps us in removing any restriction on how a parser should parse the contents. A parser can also use third party API’s as long as the output from it is in accordance with the format of a nl_sections.</p> </li> <li> <p>Since different combination of languages would need different parsers, we would create a new folder at <code class="highlighter-rouge">nestedlib/parsers</code> which would host the collection of all the parsers.</p> </li> <li> <p>A new super class called as <code class="highlighter-rouge">Parser</code> would be created. This would have all the common methods that all the parser might need. All the parser would be derived from this Superclass.</p> </li> </ul> <h3 id="parserpy-prototype">Parser.py Prototype</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">coalib.nestedlib.NlSection</span>

<span class="k">class</span> <span class="nc">Parser</span><span class="p">:</span>

	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">file_contents</span><span class="p">):</span>
		<span class="s">'''
		Returns a list of nl_sections.

		:param file_contents: The contents of the original nested file

		&gt;&gt;&gt; file_contents = </span><span class="se">\
</span><span class="s">				"""
				&lt;!DOCTYPE html&gt;
	 			&lt;head&gt;
				&lt;title&gt;Hello world as text&lt;/title&gt;
				&lt;?php
					echo "&lt;p&gt;Hello world&lt;/p&gt;";
				?&gt;
				&lt;/html&gt;
				"""

		&gt;&gt;&gt; p = Parser()
		&gt;&gt;&gt; nl_sections = p.parse(file_contents)
		&gt;&gt;&gt; nl_sections
		(	&lt;NlSection object(index=1, language=html, orig_start=1, orig_end=3)&gt;,
			&lt;NlSection object(index=2, language=php, orig_start=4, orig_end=6)&gt;,
			&lt;NlSection object(index=3, language=html, orig_start=7, orig_end=7)&gt;
		)
		'''</span>

	<span class="k">def</span> <span class="nf">detect_language</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
		<span class="s">"""
		Return the language of the particulat string.

		This will be overridden by the child class
		"""</span>

	<span class="k">def</span> <span class="nf">create_nl_section</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">language</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="s">"""
		Creates a NlSection Object from the values.

		Returns the NlSection object
		"""</span>

		<span class="k">return</span> <span class="n">NlSection</span><span class="o">.</span><span class="n">from_values</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="n">language</span><span class="p">,</span>
					     <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

</code></pre></div></div> <h3 id="making-temporary-files">Making temporary files</h3> <p>This sections deals with how the segregated section (nl_sections) from the parser are combined to form different temporary files on which linting will be done.</p> <p><code class="highlighter-rouge">NlFileHandler</code> is responsible to create the temporary files. These temporary files are stored in the memory.</p> <ol> <li> <p>The nl_sections are passed to NlFileHandler.</p> </li> <li> <p>NlFileHander then creates a <code class="highlighter-rouge">nl_file_dict</code>, where the key is the name of the temporary file and the contents are it’s value. It is similar to the <code class="highlighter-rouge">file_dict</code> that is created by coala in <code class="highlighter-rouge">instantiate_process()</code> during the execution of the section.</p> </li> <li> <p>It is important to keep in mind, that the temporary segregated file are not actually present in the folder. In the normal flow of coala,during the execution of the coala sections, coala will try to find the files by the filenames mentioned in the coala section. And then create a <code class="highlighter-rouge">file_dict</code>. That cannot happen in our case. So we will explicitly replace the <code class="highlighter-rouge">file_dict</code> with <code class="highlighter-rouge">nl_file_dict</code>.</p> </li> </ol> <h3 id="nlfilehandlerpy-prototype">NlFileHandler.py Prototype</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_nl_file_dict</span><span class="p">(</span><span class="n">nl_file_info</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">):</span>
	<span class="s">"""
	Returns a nl_file_dict, where the key is the name of the temporary file
	and the value is the contents of that file.

	:param nl_file_info:	The information extracted from the arguments.
				This is generated by the NlInfoExtractor.
	:param nl_sections:	The segregated sections of the original file.

	&gt;&gt;&gt; nl_file_info
	{
		"file_name": html_php_file.html,
		"absolute_file_path": /home/test/html_php_file.html,
		"languages": [html, php]
		"bears": [HTMLBear, PHPBear]
		"language_bear_dict": language_bear_dict
		"arg_dict": arg_dict
	}

	&gt;&gt;&gt; nl_sections
	(	&lt;NlSection object(index=1, language=html, orig_start=1, orig_end=3)&gt;,
		&lt;NlSection object(index=2, language=php, orig_start=4, orig_end=6)&gt;,
		&lt;NlSection object(index=3, language=html, orig_start=7, orig_end=7)&gt;
	)

	&gt;&gt;&gt; file_contents = get_file(nl_file_info['file_name'])

	&gt;&gt;&gt; file_contents = </span><span class="se">\
</span><span class="s">			'''
			&lt;!DOCTYPE html&gt;
 			&lt;head&gt;
			&lt;title&gt;Hello world as text&lt;/title&gt;
			&lt;?php
				echo "&lt;p&gt;Hello world&lt;/p&gt;";
			?&gt;
			&lt;/html&gt;
			'''

	&gt;&gt;&gt; nl_file_dict = get_nl_file_dict(nl_file_info, nl_sections)
	&gt;&gt;&gt; nl_file_dict
	{
		"temp_html_file":('''&lt;!DOCTYPE html&gt;</span><span class="se">\n</span><span class="s">
				&lt;head&gt;</span><span class="se">\n</span><span class="s"> 
				&lt;title&gt;Hello world as text&lt;/title&gt;</span><span class="se">\n</span><span class="s"> 
				</span><span class="se">\n</span><span class="s">
				</span><span class="se">\n</span><span class="s"> 		
				</span><span class="se">\n</span><span class="s">  
				&lt;/html&gt;'''),

		"temp_php_file":('''</span><span class="se">\n</span><span class="s">
				</span><span class="se">\n</span><span class="s">
				</span><span class="se">\n</span><span class="s">
				</span><span class="se">\t\t</span><span class="s">&lt;?php</span><span class="se">\n</span><span class="s">
				</span><span class="se">\t\t\t</span><span class="s">echo "&lt;p&gt;Hello world&lt;/p&gt;";</span><span class="se">\n</span><span class="s">
				</span><span class="se">\t</span><span class="s">?&gt;''')


	}

	"""</span>

<span class="k">def</span> <span class="nf">get_file_contents</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
	<span class="s">""" Returns the contents of the file"""</span>

<span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="n">nl_diff_dict</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_info_dict</span><span class="p">):</span>
	<span class="s">"""
	Assembles the temporary files. 

	The sections are extracted by their increasing order of their index and 
	then written directly to the original file.
	"""</span>
	<span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">[</span><span class="s">'absolute_file_path'</span><span class="p">],</span> <span class="s">'w'</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">nl_section</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nl_sections</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
		<span class="n">temp_file_name</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">temp_file</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">linted_start</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">linted_end</span>
		<span class="n">linted_file_content</span> <span class="o">=</span> <span class="n">nl_diff_dict</span><span class="p">[</span><span class="n">temp_file_name</span><span class="p">]</span>

		<span class="n">section_content</span> <span class="o">=</span> <span class="n">get_file_content</span><span class="p">(</span><span class="n">linted_file_content</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

		<span class="nb">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">section_content</span><span class="p">)</span>


</code></pre></div></div> <h2 id="phase-3-linting-the-file">Phase 3: Linting the file</h2> <p>This phase deals with linting the temporary files created by the NlFileHandler using the <code class="highlighter-rouge">nl_sections</code>.</p> <ol> <li> <p>In coala the linting of the files are done when the section created by coala are executed.</p> </li> <li> <p>Since we are explicitly making the sections for nested languages, care has been taken to keep the file names of the <code class="highlighter-rouge">nl.lang</code> section and the file names in <code class="highlighter-rouge">nl_file_dict</code> same.</p> </li> <li> <p>During the execution of the section, in the <code class="highlighter-rouge">instantiate_process()</code> we do not access the physical file, rather we replace the <code class="highlighter-rouge">file_dict</code> with <code class="highlighter-rouge">nl_file_dict</code> and make the necessary changes.</p> </li> <li> <p>Once the <code class="highlighter-rouge">file_dict</code> is changed, coala will normally continue the process. To coala, it now looks as if the <code class="highlighter-rouge">temporary files</code> were actually present in the physical drive. And the linting starts</p> </li> </ol> <h3 id="applying-the-patches">Applying the Patches</h3> <p>Whenever the bears suggests a patch and the user desires to apply the Patch, we would also need to update the information of the <code class="highlighter-rouge">linted_start</code> and <code class="highlighter-rouge">linted_end</code>. This needs to be done because, whenever a patch is applied the position of the lines might change because of addition and deletion of lines.</p> <p>Keeping track of the start and end of a particular <code class="highlighter-rouge">nl_section</code> in the linted files would help in easier extraction of the <code class="highlighter-rouge">nl_section</code> from the temporary created files.</p> <p>In order to do so, we’ll have to make changes to the <code class="highlighter-rouge">apply()</code> method of the <code class="highlighter-rouge">ApplyAction</code>. We use the <code class="highlighter-rouge">update_nl_sections()</code> functions to update the values.</p> <p>In <code class="highlighter-rouge">Diff.py</code> we add a new function <code class="highlighter-rouge">get_diff_info()</code> that would give us the information of the diff</p> <h4 id="diffpy">Diff.py</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_diff_info</span><span class="p">():</span>
	<span class="s">"""
	Returns tuple containing line numbers of deleted,changed and added lines.
	"""</span>
	<span class="n">deleted_lines</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">added_lines</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">changed_lines</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="k">for</span> <span class="n">line_nr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_changes</span><span class="p">:</span>
		<span class="n">line_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_changes</span><span class="p">[</span><span class="n">line_nr</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">line_diff</span><span class="o">.</span><span class="n">change</span><span class="p">:</span>
			<span class="n">changed_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_nr</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">line_diff</span><span class="o">.</span><span class="n">delete</span><span class="p">:</span>
			<span class="n">deleted_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_nr</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">line_diff</span><span class="o">.</span><span class="n">add_after</span><span class="p">:</span>
			<span class="n">added_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_nr</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">changed_lines</span><span class="p">,</span> <span class="n">deleted_lines</span><span class="p">,</span> <span class="n">added_lines</span>
</code></pre></div></div> <h3 id="nlcorepy">NLCore.py</h3> <p>The following method belongs to the NlCore</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">coalib.result_action.Diff</span> <span class="kn">import</span> <span class="n">stats</span><span class="p">,</span><span class="n">get_diff_info</span>

<span class="n">diff_stats</span> <span class="o">=</span> <span class="n">stats</span><span class="p">()</span>
<span class="n">diff_info</span> <span class="o">=</span> <span class="n">get_diff_info</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">find_section_index</span><span class="p">(</span><span class="n">diff_stats</span><span class="p">,</span> <span class="n">diff_info</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">):</span>
	<span class="s">"""
	Returns the section index to which the patch is about to be applied.
	"""</span>

	<span class="k">return</span> <span class="n">index</span>

<span class="k">def</span> <span class="nf">update_nl_sections</span><span class="p">(</span><span class="n">diff_stats</span><span class="p">,</span> <span class="n">diff_info</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">):</span>
	<span class="s">"""
	Updates the `linted_start` and the `linted_end` of the nl_sections 
	"""</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">find_section_index</span><span class="p">(</span><span class="n">diff_stats</span><span class="p">,</span> <span class="n">diff_info</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">nl_sections</span> <span class="ow">in</span> <span class="n">nl_sections</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
			<span class="s">"""
			Update the values of linted_start` and the `linted_end`
			"""</span>

</code></pre></div></div> <h2 id="phase-4-assembling">Phase 4: Assembling</h2> <p>This phase deals with assembling the linted temporary files back into the original file.</p> <p>This phase has two parts:</p> <ol> <li>Extracting the sections from the linted temporary files.</li> <li>Assembling these sections.</li> </ol> <p>Once all the coala sections have been executed, we have a <code class="highlighter-rouge">nl_diff_dict</code> where the key is the name of the temporary file and the value is the contents of the linted file contents of the temporary file.</p> <p>We have a <code class="highlighter-rouge">assemble()</code> method inside the NlFileHandler, which uses the information from the <code class="highlighter-rouge">nl_sections</code> and extracts the sections from the <code class="highlighter-rouge">nl_diff_dict</code> and write it to the original file</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="n">nl_diff_dict</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_info_dict</span><span class="p">):</span>
	<span class="s">"""
	Assembles the temporary files. 

	The sections are extracted by their increasing order of their index and 
	then written directly to the original file.
	"""</span>
	<span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">[</span><span class="s">'absolute_file_path'</span><span class="p">],</span> <span class="s">'w'</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">nl_section</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nl_sections</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
		<span class="n">temp_file_name</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">temp_file</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">linted_start</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">linted_end</span>
		<span class="n">linted_file_content</span> <span class="o">=</span> <span class="n">nl_diff_dict</span><span class="p">[</span><span class="n">temp_file_name</span><span class="p">]</span>

		<span class="n">section_content</span> <span class="o">=</span> <span class="n">get_file_content</span><span class="p">(</span><span class="n">linted_file_content</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

		<span class="nb">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">section_content</span><span class="p">)</span>

</code></pre></div></div> <h2 id="nlcorepy-prototype">NlCore.py Prototype</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">coalib.nestedlib.NlInfoExtractor</span> <span class="kn">import</span> <span class="n">extract_info</span>
<span class="kn">from</span> <span class="nn">coalib.result_action.Diff</span> <span class="kn">import</span> <span class="n">stats</span><span class="p">,</span><span class="n">get_diff_info</span>
<span class="kn">from</span> <span class="nn">coalib.nestedlib.NlFileHandler</span> <span class="kn">import</span> <span class="n">get_file_contents</span><span class="p">,</span> <span class="n">get_nl_file_dict</span><span class="p">,</span> <span class="n">assemble</span>

<span class="kn">import</span> <span class="nn">coalib.nestedlib.Parser</span>

<span class="k">def</span> <span class="nf">get_arg_info</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
	<span class="s">"""
	Return argument list and nl_info_dict that  will be used to make 
	the coala sections

	&gt;&gt;&gt; arg_list = get_arg_list(arg)
	[ ( (file, temp_html_file), (bears, HTMLBear ), (settings, value) ),
	  ( (file, temp_php_file), (bears, PHPBear ), (settings, value) )
	]

	"""</span>
	<span class="n">nl_info_dict</span> <span class="o">=</span> <span class="n">extract_info</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
	<span class="n">arg_list</span> <span class="o">=</span> <span class="n">make_arg_list</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">nl_info_dict</span><span class="p">,</span> <span class="n">arg_list</span>

<span class="k">def</span> <span class="nf">get_file_metadata</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">):</span>
	<span class="s">"""
	Returns the nl_sections and nl_file_dict
	"""</span>

	<span class="n">parser</span> <span class="o">=</span> <span class="n">detect_parser</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">[</span><span class="s">'languages'</span><span class="p">])</span>
	<span class="n">file_contents</span> <span class="o">=</span> <span class="n">get_file_contents</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">[</span><span class="s">'absolute_file_path'</span><span class="p">])</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">find_section_index</span><span class="p">(</span><span class="n">diff_stats</span><span class="p">,</span> <span class="n">diff_info</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">nl_sections</span> <span class="ow">in</span> <span class="n">nl_sections</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">nl_section</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
			<span class="s">"""
			Update the values of linted_start` and the `linted_end`
			"""</span>


<span class="k">def</span> <span class="nf">assemble_files</span><span class="p">(</span><span class="n">nl_diff_dict</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_info_dict</span><span class="p">):</span>
	<span class="s">"""
	Assembles the file and returns back to coala_main
	"""</span>

	<span class="k">return</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nl_diff_dict</span><span class="p">,</span> <span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_info_dict</span><span class="p">)</span>

</code></pre></div></div> <h2 id="changes-in-coalapy">Changes in coala.py</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">coalib.nestedlib.Nlcore</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="n">configure_logging</span><span class="p">()</span>
	<span class="n">handle_nested</span> <span class="o">=</span> <span class="bp">True</span>

	<span class="n">args</span> <span class="o">=</span> <span class="bp">None</span> 	<span class="c1"># to have args variable in except block 
</span>					<span class="c1">#  when parse_args fails
</span>	<span class="k">try</span><span class="p">:</span>
		<span class="n">args</span> <span class="o">=</span> <span class="n">default_arg_parser</span><span class="p">()</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">handle_nested</span><span class="p">:</span>
			<span class="n">nl_info_dict</span><span class="p">,</span> <span class="n">nl_arg_dict</span> <span class="o">=</span> <span class="n">get_arg_info</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
			<span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_file_dict</span> <span class="o">=</span> <span class="n">get_file_metadata</span><span class="p">(</span><span class="n">nl_info_dict</span><span class="p">)</span>

		<span class="s">"""
		
		Code Contents of of coala.py

		"""</span>

	<span class="k">return</span> <span class="n">mode_normal</span><span class="p">(</span><span class="n">console_printer</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> 
			<span class="n">handle_nested</span><span class="p">,</span> <span class="n">nl_info_dict</span><span class="p">,</span> <span class="n">nl_arg_dict</span><span class="p">,</span> 
			<span class="n">nl_sections</span><span class="p">,</span> <span class="n">nl_file_dict</span><span class="p">)</span>

</code></pre></div></div> </div> </article> <footer class="site-footer"> <div class="container"> <small class="block">&copy; 2019 Naveen Naidu &middot; &lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/thinkspace">Thinkspace theme</a></small> </div> </footer> </main> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-XXXXX-XX']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> </body> </html>
